
SET KSC to SHIP:GEOPOSITION.

// Function to measure Cd
function MEASURECD {
	LOCK STEERING TO HEADING(90,90).
	LOCK THROTTLE TO 1.0.
	SET DELTATIME TO 0.1.
	SET LASTTIME TO TIME:SECONDS.
	SET VVACC TO 1.
	SET LASTVV TO 0.
	SET SUMCD TO 0.
	SET SUMCDI TO 0.
	SET FILTERCD TO 1.0.
	SET ITERATIONS TO 20000.
	UNTIL (SHIP:VERTICALSPEED > 200.0)
	{
		SET ITERATIONS TO ITERATIONS - 1.
		//PRINTDATA().
	// Measure Cd...
		WAIT 0.01.
		SET DELTATIME TO TIME:SECONDS - LASTTIME.
		SET LASTTIME TO TIME:SECONDS.
		SET VVACC TO (SHIP:VERTICALSPEED - LASTVV)/DELTATIME.
		SET LASTVV TO SHIP:VERTICALSPEED.
		lock g to GETGATALT(altitude).
		SET ENGINEPUSH TO ((SHIP:MAXTHRUST*1000)/(SHIP:MASS*1000)) - g.
		//PRINT "ENGINEPUSH: " + ENGINEPUSH AT (0,24).
		
		SET REMAININGACC TO VVACC - ENGINEPUSH.
		//SET REMAININGACC TO REMAININGACC - g.
		
		//PRINT "REMAINING ACC: " + REMAININGACC AT (0,18).
		SET AEROFORCE TO REMAININGACC*(SHIP:MASS*1000).
		//PRINT "AEROFORCE: " + AEROFORCE AT (0,19).
		SET CALCQ TO (GETDENSITY(ALTITUDE) * 0.5 * SHIP:AIRSPEED * SHIP:AIRSPEED).
		SET TRUEQ TO SHIP:Q*101325.
		//PRINT "CALC QV: " + CALCQ AT (0,22).
		//PRINT "Cd: " + AEROFORCE/CALCQ AT (0,20).
		//PRINT "Cd: " + AEROFORCE/SHIP:Q AT (0,21).
		IF (SHIP:VERTICALSPEED > 50.0 AND SHIP:VERTICALSPEED < 200.0)
		{
			SET SUMCD TO (SUMCD - (AEROFORCE/CALCQ)).
			SET SUMCDI TO (SUMCDI + 1).
			SET FILTERCD TO (FILTERCD * 0.9) + ((-AEROFORCE/CALCQ)*0.1).
			PRINT "Filtercd: " + FILTERCD AT (0,24).
			PRINT "Sumcd: " + SUMCD AT (0,25).
			print "Sumcdi: " + SUMCDI AT (0,26).
			PRINT "Av Cd: " + (SUMCD/SUMCDI) AT (0,27).
			PRINT "SHIPMASS : " + SHIP:MASS AT (0,28).
			SET Cd TO (SUMCD/SUMCDI) / 1000.
			SET Cd To FILTERCD / 1000.
		}
	}.
	//SET Cd TO (SUMCD/SUMCDI).
	PRINT "Av Cd: " + (SUMCD/SUMCDI) AT (0,22).
}.

// Simple get to orbit code
SET TARGETALT TO 85000.
STAGE.
function ASCEONDTOORBIT {
	SET HASMEASUREDCD TO 0.
	UNTIL (APOAPSIS > TARGETALT * 0.999 AND PERIAPSIS > TARGETALT * 0.999)
	{
		SET ALTRATIO TO ALTITUDE/TARGETALT.
		SET APORATIO TO APOAPSIS/TARGETALT.
		LOCK STEERING TO HEADING(90,90 - (90*APORATIO)).
		
		// This will make it burn full throttle 3/4 of the ascent.
		SET ASCENTBURN TO (4.0-(APORATIO*4.0)).
		IF (ASCENTBURN < 0)
		{
			SET ASCENTBURN TO 0.
		}
		// A little push for circularization.
		SET TIMETOAPO TO (APOAPSIS-ALTITUDE)/ABS(SHIP:VERTICALSPEED).
		SET APOPERIRATIO TO (PERIAPSIS/APOAPSIS).
		SET CIRCBURN TO (1-APOPERIRATIO)/TIMETOAPO.
		PRINT "TIME TO APO: " + TIMETOAPO AT (0,0).
		PRINT "ASCENTBURN: " + ASCENTBURN AT (0,1).
		PRINT "APORATIO: " + APORATIO AT (0,2).
		PRINT "APOPERIRATIO: " + APOPERIRATIO AT (0,3).
		PRINT "CIRBURN: " + CIRCBURN AT (0,4).
		
		// Combine the two.
		LOCK THROTTLE TO ASCENTBURN+CIRCBURN.
		
		WAIT 0.25.
		IF (HASMEASUREDCD = 0 AND ALTITUDE < 500)
		{
			MEASURECD().
			SET HASMEASUREDCD TO 1.
		}

		
		//PRINT "THROTTLE " + CIRCBURN AT (0,8).
		//WAIT 0.01.

	}
	LOCK THROTTLE TO 0.
}.

function CIRCULARIZE {
	LOCK STEERING TO PROGRADE.
	SET INITIALAPO TO APOAPSIS.
	// Wait until ship is ascending
	UNTIL (SHIP:VERTICALSPEED > 0)
	{
		WAIT 1.
	}
	SET TIMETOAPO TO (APOAPSIS-ALTITUDE)/SHIP:VERTICALSPEED.
	PRINT "TIMETO APO: "+ TIMETOAPO.
	UNTIL (TIMETOAPO < 10)
	{
		// Wait until 10 seconds remain to apo.
		WAIT TIMETOAPO-10.
		SET TIMETOAPO TO (APOAPSIS-ALTITUDE)/SHIP:VERTICALSPEED.
	}
	SET THROTTLE TO 1-(APOAPSIS/PERIAPSIS).
	
	UNTIL (PERIAPSIS > INITIALAPO)
	{
		SET TIMETOAPO TO (APOAPSIS-ALTITUDE)/SHIP:VERTICALSPEED.
		SET APOPERIRATIO TO (PERIAPSIS/APOAPSIS).
		SET CIRCBURN TO (1-APOPERIRATIO)/TIMETOAPO.
		SET THROTTLE TO CIRCBURN.
		PRINT "THROTTLE " + CIRCBURN AT (0,8).
		WAIT 0.01.
	}
	PRINT "CIRCULARIZED".
	LOCK THROTTLE TO 0.
}.


function GETDENSITY {
	parameter altitude.
	set LOWDENS TO 0.
	set HIGHDENS TO 0.
	SET MIX TO 1.
	if (altitude < 2500)
	{
		SET LOWDENS TO 1.225.
		SET HIGHDENS TO 0.898.
		SET MIX TO altitude/2500.
	} else if (altitude < 5000)
	{
		SET LOWDENS TO 0.898.
		SET HIGHDENS TO  0.642 .
		SET MIX TO (altitude-2500)/2500.
	} else if (altitude < 7500)
	{
		SET LOWDENS TO  0.642 .
		SET HIGHDENS TO 0.446.
		SET MIX TO (altitude-5000)/2500.
	} else if (altitude < 10000)
	{
		SET LOWDENS TO 0.446.
		SET HIGHDENS TO 0.288.
		SET MIX TO (altitude-7500)/2500.
	} else if (altitude < 15000)
	{
		SET LOWDENS TO 0.288.
		SET HIGHDENS TO 0.108 .
		SET MIX TO (altitude-10000)/5000.
	} else if (altitude < 20000)
	{
		SET LOWDENS TO 0.108.
		SET HIGHDENS TO 0.040 .
		SET MIX TO (altitude-15000)/5000.
	} else if (altitude < 25000)
	{
		SET LOWDENS TO 0.040 .
		SET HIGHDENS TO  	0.015 .
		SET MIX TO (altitude-20000)/5000.
	} else if (altitude < 30000)
	{
		SET LOWDENS TO  	0.015 .
		SET HIGHDENS TO 0.006 .
		SET MIX TO (altitude-25000)/5000.
	} else if (altitude < 40000)
	{
		SET LOWDENS TO 0.006 .
		SET HIGHDENS TO 0.001.
		SET MIX TO (altitude-30000)/10000.
	} else if (altitude < 70000)
	{
		SET LOWDENS TO 0.001.
		SET HIGHDENS TO 0.0001.
		SET MIX TO (altitude-40000)/30000.
	} else
	{
		RETURN 0.
	}
	RETURN (LOWDENS*(1-MIX))+(HIGHDENS*(MIX)).
}.

function GETGATALT {
	parameter ALTITUDETOCHECK.
	return body:mu / (ALTITUDETOCHECK + body:radius)^2.
}.

// Simple back-of-the envelope calculation from NASAs webpage.
function GETBALLISTICX {
	parameter STARTINGALT.
	parameter Uo.
	parameter Vo.
	parameter Cd.
	
	SET g to GETGATALT(STARTINGALT).
	SET Vt TO SQRT((2*SHIP:MASS*g)/((Cd*GETDENSITY(STARTINGALT))+0.000001)).
	SET ESTFALLTIME TO (Vo/g)*2.
	SET ymax TO (Vt^2 / (2 * g)) * ln ((Vo^2 + Vt^2)/Vt^2).
	SET ITERATIONS TO 5.
	UNTIL (ITERATIONS = 0)
	{

		SET NEWG TO GETGATALT(STARTINGALT+ymax).
		SET Vt TO SQRT((2*SHIP:MASS*NEWG)/((Cd*GETDENSITY((STARTINGALT+ymax)/2)))+0.000001).
		SET ymax TO (Vt^2 / (2 * NEWG)) * ln ((Vo^2 + Vt^2)/Vt^2).
		SET AVGG TO (g+NEWG)/2.
		SET FALLTIMENEW TO (Vo/AVGG)*2.
		
		SET X TO ((Vt*Vt)/AVGG)*(LN(((Vt*Vt)+AVGG*Uo*FALLTIMENEW)/(Vt*Vt))).
		
		SET ITERATIONS TO ITERATIONS - 1.
	}.
	RETURN X.
}

function GETAEROFORCE {
	parameter ALTITUDETOCHECK.
	parameter VEL.
	parameter CD.
	SET Q TO (GETDENSITY(ALTITUDETOCHECK) * 0.5 * VEL * VEL).
	RETURN Q * CD.
}.

function GETCURVEDDIST {
	parameter DIRECTDIST.
	parameter ALTITUDETOCHECK.
	SET ALTABOVECENTER TO Kerbin:RADIUS + ALTITUDETOCHECK.
	SET DISTINRAD TO ARCTAN(DIRECTDIST/ALTABOVECENTER) * Constant:DegToRad.
	RETURN DISTINRAD * Kerbin:RADIUS.
}

function GETSTRAIGHTDIST {
	parameter CURVEDDIST.
	parameter ALTITUDETOCHECK.
	SET A TO CURVEDDIST / Kerbin:RADIUS.
	SET B TO A / CONSTANT:DegToRad.
	SET C TO TAN(B).
	SET ALTABOVECENTER TO Kerbin:RADIUS + ALTITUDETOCHECK.
	RETURN C * ALTABOVECENTER.
}

// RETURN LIST(CURRENTALT, DISTANCEX, CURRENTHORV, CURRENTVERV)
function TRAJECTORYSTEP {
	parameter PCURRENTALT.
	parameter PCURRENTHORV.
	parameter PCURRENTVERV.
	parameter PDT.

	LOCAL LSMASS TO SHIP:MASS * 1000.

	LOCAL LAERODYNAMICFORCEHOR TO GETAEROFORCE(PCURRENTALT, PCURRENTHORV, Cd).
	LOCAL LAERODYNAMICFORCEVER TO GETAEROFORCE(PCURRENTALT, PCURRENTVERV, Cd).

	LOCAL LNEWHORV TO PCURRENTHORV - ((LAERODYNAMICFORCEHOR / LSMASS)*PDT).
	LOCAL LNEWVERV TO 0.
	IF (PCURRENTVERV > 0)
	{
		SET LNEWVERV TO PCURRENTVERV - ((LAERODYNAMICFORCEVER / LSMASS) * PDT).
	} ELSE {
		// I guess if falling the vertical drag is applied upwards.
		SET LNEWVERV TO PCURRENTVERV + ((LAERODYNAMICFORCEVER / LSMASS) * PDT).
	}
	// Apply G.
	SET LNEWVERV TO LNEWVERV - (GETGATALT(PCURRENTALT) * PDT).

	// Add the horv that is added as vertical V because we are
	// "missing" the body (ie orbit). Maybe do this somehow for horv too?
	LOCAL LRADIALDIST TO PCURRENTALT + Kerbin:RADIUS.
	SET LNEWVERV TO LNEWVERV + (SQRT((LNEWHORV*LNEWHORV)+(LRADIALDIST*LRADIALDIST))-LRADIALDIST).

	// Prepare for next iteration.
	LOCAL RCURRENTHORV TO LNEWHORV.
	LOCAL RCURRENTVERV TO LNEWVERV.
	LOCAL RCURRENTALT TO PCURRENTALT + RCURRENTVERV.
	LOCAL RDISTANCEX TO GETCURVEDDIST(RCURRENTHORV, RCURRENTALT).
	
	// Return a list
	RETURN LIST(RCURRENTALT, RDISTANCEX, RCURRENTHORV, RCURRENTVERV).
}

// RETURN LIST(CURRENTALT, DISTANCEX, CURRENTHORV, CURRENTVERV)
function RK4Step {
	parameter CURRENTALT.
	parameter CURRENTHORV.
	parameter CURRENTVERV.
	parameter DT.

	SET f0 TO TRAJECTORYSTEP( CURRENTALT, CURRENTHORV, CURRENTVERV, DT).//t0, u0 );

  	SET t1 TO DT/2.0.//t1 = t0 + dt / 2.0;
	SET a1 TO CURRENTALT + (DT * (f0[0]-CURRENTALT)/2.0).
	SET u1 TO CURRENTVERV + (DT * (f0[3]-CURRENTVERV) / 2.0). //u1 = u0 + dt * f0 / 2.0;
	SET v1 TO CURRENTHORV + (DT * (f0[2]-CURRENTHORV) / 2.0). 
	SET x1 TO 0 + (DT * f0[1] / 2.0). 
  	SET f1 TO TRAJECTORYSTEP(a1, v1, u1, DT/2).//f1 = f ( t1, u1 );

	SET t2 TO DT/2.0.//t2 = t0 + dt / 2.0;
	SET a2 TO CURRENTALT + (DT * (f1[0]-CURRENTALT)/2.0).
	SET u2 TO CURRENTVERV + (DT * (f1[3]-CURRENTVERV) / 2.0). //u2 = u0 + dt * f1 / 2.0;
	SET v2 TO CURRENTHORV + (DT * (f1[2]-CURRENTHORV) / 2.0).
	SET x2 TO 0 + (DT * f1[1] / 2.0).
  	SET f2 TO TRAJECTORYSTEP(a2, v2, u2, DT/2).//f2 = f ( t2, u2 );

  	SET t3 TO DT.//t3 = t0 + dt;
	SET a3 TO CURRENTALT + (DT * (f2[0]-CURRENTALT)).
	SET u3 TO CURRENTVERV + (DT * (f2[3]-CURRENTVERV)). //u3 = u0 + dt * f2;
	SET v3 TO CURRENTHORV + (DT * (f2[2]-CURRENTHORV)). 
	SET x3 TO 0 + (DT * f2[1]).
  	SET f3 TO TRAJECTORYSTEP(a3, v3, u3, DT).//f3 = f ( t3, u3 );


	//PRINT "a0 " + CURRENTALT + " a1 " + a1 + " a2 " + a2 + " a3 " + a3.
	//
	//  Combine to estimate the solution at time T0 + DT.
	//
	SET a TO (f0[0] + 2.0 * f1[0] + 2.0 * f2[0] + f3[0]) / 6.0. //u = u0 + dt * ( f0 + 2.0 * f1 + 2.0 * f2 + f3 ) / 6.0;
  	SET u TO (f0[3] + 2.0 * f1[3] + 2.0 * f2[3] + f3[3]) / 6.0. //u = u0 + dt * ( f0 + 2.0 * f1 + 2.0 * f2 + f3 ) / 6.0;
	SET v TO (f0[2] + 2.0 * f1[2] + 2.0 * f2[2] + f3[2]) / 6.0. //u = u0 + dt * ( f0 + 2.0 * f1 + 2.0 * f2 + f3 ) / 6.0;
	SET x TO 0 + DT * (f0[1] + 2.0 * f1[1] + 2.0 * f2[1] + f3[1]) / 6.0. //u = u0 + dt * ( f0 + 2.0 * f1 + 2.0 * f2 + f3 ) / 6.0;

	RETURN LIST(a, x, v, u).
}

function GETEULERBALLX {
	// Iterative Euler method.
	parameter STARTINGALT.
	parameter ENDALT.
	parameter Uo.
	parameter Vo.
	parameter Cd.
	SET DT to 1.
	SET ITERATIONS TO 1000.
	SET CURRENTALT TO STARTINGALT.
	SET CURRENTHORV TO Uo.
	SET CURRENTVERV TO Vo.
	SET DISTANCEX TO 0.
	SET SMASS TO SHIP:MASS * 1000.
	//PRINT "CURRENTALT: " + CURRENTALT.
	//PRINT "CURRENTHORV: " + CURRENTHORV.
	//PRINT "CURRENTVERV: " + CURRENTVERV.
	//PRINT "DISTANCEX: " + DISTANCEX.
	//PRINT "ITERATION: " + ITERATIONS.
	//PRINt "SHIP MASS: " + SMASS.
	UNTIL (ITERATIONS = 0)
	{
		SET ESTIMATE TO TRAJECTORYSTEP(CURRENTALT, CURRENTHORV, CURRENTVERV, 1.0).

		// Prepare for next iteration.
		SET CURRENTHORV TO ESTIMATE[2].
		SET CURRENTVERV TO ESTIMATE[3].
		SET CURRENTALT TO ESTIMATE[0].
		SET DISTANCEX TO DISTANCEX + ESTIMATE[1].
		
		//PRINT "CURRENTALT: " + CURRENTALT.
		//PRINT "CURRENTHORV: " + CURRENTHORV.
		//PRINT "CURRENTVERV: " + CURRENTVERV.
		//PRINT "DISTANCEX: " + DISTANCEX.
		//PRINT "ITERATION: " + ITERATIONS.
		IF (CURRENTALT < ENDALT) 
		{
			// End iterations.
			SET ITERATIONS TO 0.
		} ELSE {
			// Continue iterations.
			SET ITERATIONS TO ITERATIONS - 1.
			IF (ITERATIONS = 0)
			{
				PRINT "NO SOLUTION FOUND!".
				PRINT "NO SOLUTION FOUND!" AT (10,0).
				RETURN -1.
			}
		}
	}.
	RETURN DISTANCEX.
}.

function GETRK4BALLX {
	// Iterative RK4 method.
	parameter STARTINGALT.
	parameter ENDALT.
	parameter Uo.
	parameter Vo.
	parameter Cd.
	SET DT to 1.
	SET ITERATIONS TO 1000.
	SET CURRENTALT TO STARTINGALT.
	SET CURRENTHORV TO Uo.
	SET CURRENTVERV TO Vo.
	SET DISTANCEX TO 0.
	SET SMASS TO SHIP:MASS * 1000.
	//PRINT "CURRENTALT: " + CURRENTALT.
	//PRINT "CURRENTHORV: " + CURRENTHORV.
	//PRINT "CURRENTVERV: " + CURRENTVERV.
	//PRINT "DISTANCEX: " + DISTANCEX.
	//PRINT "ITERATION: " + ITERATIONS.
	//PRINt "SHIP MASS: " + SMASS.
	UNTIL (ITERATIONS = 0)
	{
		// RETURN LIST(CURRENTALT, DISTANCEX, CURRENTHORV, CURRENTVERV)
		//function RK4Step {
	//parameter CURRENTALT.
	//parameter CURRENTHORV.
	//parameter CURRENTVERV.
	//parameter DT.
		SET ESTIMATE TO RK4Step(CURRENTALT, CURRENTHORV, CURRENTVERV, 1.0).

		// Prepare for next iteration.
		SET CURRENTHORV TO ESTIMATE[2].
		SET CURRENTVERV TO ESTIMATE[3].
		SET CURRENTALT TO ESTIMATE[0].
		SET DISTANCEX TO DISTANCEX + ESTIMATE[1].
		//PRINT "CURRENTALT: " + CURRENTALT.
		//PRINT "CURRENTHORV: " + CURRENTHORV.
		//PRINT "CURRENTVERV: " + CURRENTVERV.
		//PRINT "DISTANCEX: " + DISTANCEX.
		//PRINT "ITERATION: " + ITERATIONS.
		IF (CURRENTALT < ENDALT) 
		{
			// End iterations.
			SET ITERATIONS TO 0.
		} ELSE {
			// Continue iterations.
			SET ITERATIONS TO ITERATIONS - 1.
			IF (ITERATIONS = 0)
			{
				PRINT "NO SOLUTION FOUND!".
				PRINT "NO SOLUTION FOUND!" AT (10,0).
				RETURN -1.
			}
		}
	}.
	RETURN DISTANCEX.
}.

function GETGROUNDDIST {
	parameter POS.
	// Calculating geographical distance.
	SET POSDISTGEO TO SQRT(((POS:LNG-SHIP:GEOPOSITION:LNG)*(POS:LNG-SHIP:GEOPOSITION:LNG))+((POS:LAT-SHIP:GEOPOSITION:LAT)*(POS:LAT-SHIP:GEOPOSITION:LAT))).
	// Calculate it to meters.
	RETURN (POSDISTGEO/180)*(CONSTANT:PI*Kerbin:RADIUS).
}

LOCK CALCHORV TO COS((ARCSIN(SHIP:VERTICALSPEED/SHIP:AIRSPEED)))*SHIP:AIRSPEED.
function PRINTDATA {
	SET Cd TO 0.007.
	
	//PRINT "CURRENT X:" + GETBALLISTICX(ALTITUDE, SHIP:VERTICALSPEED, CALCHORV, Cd) at (20,0).
	PRINT "KSCDIST: " + GETGROUNDDIST(KSC) at (20,1).
}

function DEORBIT {
	parameter DEORBITALT.
	parameter DEORBITV.
	// First calculate a deorbit burn which would put the impact point on the
	// other side of Kerbin
	
	

	//SET DEORBITV TO 4049. // TEST
	//SET DEORBITALT TO 89000. // TEST
	PRINT "DEORBITBURN DIST: " + Kerbin:RADIUS * CONSTANT:PI AT (0,7).
	PRINT "INITALV: " + DEORBITV AT (0,8).
	PRINT "INITALT: " + DEORBITALT AT (0,9).
	SET IMPACTDIST TO Kerbin:RADIUS * CONSTANT:PI * 2.
	UNTIL (IMPACTDIST < Kerbin:RADIUS * CONSTANT:PI AND IMPACTDIST > 0)
	{
		SET DEORBITV TO DEORBITV * 0.95.
		SET IMPACTDIST TO GETRK4BALLX(DEORBITALT, 0, DEORBITV,0, Cd).
		PRINT "IMPACTDIST: " + IMPACTDIST AT (0,10).
		PRINT "DEORBITV: " + DEORBITV AT (0,11).
	}
	SET LASTDIFF TO GETGROUNDDIST(KSC)-IMPACTDIST.
	SET DEORBITV TO GETCURVEDDIST(DEORBITV, DEORBITALT).
	SET DIFF TO GETGROUNDDIST(KSC)-IMPACTDIST.
	UNTIL (GETGROUNDDIST(KSC) < IMPACTDIST + (DIFF * 100))
	{
		// Wait until burn time.
		WAIT 0.1.
		SET DIFF TO GETGROUNDDIST(KSC)-IMPACTDIST.
		SET TIMETODEORBITBURN TO ((DIFF/(LASTDIFF-DIFF))*0.1).
		SET LASTDIFF TO DIFF.
		PRINT "DEORBIT IN: " + TIMETODEORBITBURN AT (0,12).
		PRINT "DIST: " + GETGROUNDDIST(KSC) AT (0,13).
		PRINT "REMAINING DEORBIT V: " + (GETSTRAIGHTDIST(CALCHORV, DEORBITALT) - DEORBITV) AT (0,14).
		LOCK STEERING TO RETROGRADE.
		RCS ON.
	}
	UNTIL (DEORBITV > GETSTRAIGHTDIST(CALCHORV, DEORBITALT))
	{
		PRINT "REMAINING DEORBIT V: " + (GETSTRAIGHTDIST(CALCHORV, DEORBITALT) - DEORBITV) AT (0,14).
		//SET THROTTLE TO 1-(DEORBITV/CALCHORV). // 1-(100/1000) = 1-0.1 = 0.9
		SET THROTTLE TO 0.5. // HACK
	}.
	SET THROTTLE TO 0.
	LOCK STEERING TO PROGRADE.
	UNTIL (ALTITUDE < 100)
	{
		PRINTDATA().
		// Gliding test
		SET LASTESTIMATE TO 0.
		IF (SHIP:VERTICALSPEED < 0)
		{
			SET BURNDISTANCE TO GETGROUNDDIST(KSC).
			SET TRAJDIST TO GETRK4BALLX(ALTITUDE,0, CALCHORV, SHIP:VERTICALSPEED, Cd).
			
			// We need to compensate for slow computation.
			SET ESTDIFF TO TRAJDIST - LASTESTIMATE.
			SET LASTESTIMATE TO TRAJDIST.
			SET TOTALDIST TO BURNDISTANCE + TRAJDIST.
			IF ((TOTALDIST + (ESTDIFF*3)) > 0)
			{
				SET FINEADJUST TO 1.
			}
			SET IMPACTERROR TO (TOTALDIST + (ESTDIFF*2)) - 0.
			PRINT "IMPACTERROR: " + IMPACTERROR AT (20,2).

			IF (IMPACTERROR < -100)
			{
				// Try to glide further
				LOCK STEERING TO HEADING(90,5).
			} ELSE IF (IMPACTERROR > 100)
			{
				// Try to glide down
				LOCK STEERING TO HEADING(90,-90).
			} ELSE {
				LOCK STEERING TO PROGRADE.
			}
			
		}


		WAIT 10.
	}
}
CLEARSCREEN.
SET Cd TO 0.7/1000.
SET CURV TO GETCURVEDDIST(2500, 100000). 
PRINT CURV.
PRINT GETSTRAIGHTDIST(CURV, 100000).
//PRINT GETEULERBALLX(90000, 0, 4400,0, Cd).
SET TRAJTEST TO TRAJECTORYSTEP(1000,340,0,1).
PRINT "TRAJ STEP: ALT " + TRAJTEST[0] + " X " + TRAJTEST[1] + " H " + TRAJTEST[2] + " V " + TRAJTEST[3].
SET TRAJ4TEST TO RK4STEP(1000,340,0,1).
PRINT "TRAJ4 STEP: ALT " + TRAJ4TEST[0] + " X " + TRAJ4TEST[1] + " H " + TRAJ4TEST[2] + " V " + TRAJ4TEST[3].
//PRINT "EULER: " + GETEULERBALLX(1000, 0, 340,0, Cd).
//PRINT "RK4: " + GETRK4BALLX(1000, 0, 340,0, Cd).
//PRINT "NASA: " + GETBALLISTICX(1000, 340, 10, Cd).
//PRINT "EULER: " + GETEULERBALLX(100000, 0, GETSTRAIGHTDIST(2400, 100000),0, Cd).
//PRINT "RK4: " + GETRK4BALLX(100000, 0, GETSTRAIGHTDIST(2400, 100000),0, Cd).
//PRINT "NASA: " + GETBALLISTICX(100000, 3000, 10, Cd).
//PRINT GETEULERBALLX(500,0,1100,0,Cd).
//PRINT GETEULERBALLX(90000, 0, 1100,0, Cd).
//WAIT 10.
//DEORBIT(85000, GETSTRAIGHTDIST(2200, DEORBITALT)).
ASCEONDTOORBIT().
SET DEORBITALT TO (APOAPSIS+PERIAPSIS)/2.0. // Likely deorbit altitude
SET DEORBITV TO GETSTRAIGHTDIST(SHIP:AIRSPEED, DEORBITALT).
DEORBIT(DEORBITALT, DEORBITV).

//CIRCULARIZE().


CLEARSCREEN.
PRINT "*** BALLISTIC BURN TEST ***" AT (0,0).
STAGE.
SET Cd TO 0.7/1000.
SET Vo TO 320.
SET Uo TO 200.
SET TARGETDIST TO 400000.
SET TRAJECTORYANGLE TO (ARCTAN(Vo/Uo)).//* constant:RadToDeg.
PRINT "TRAJECTORYANGLE: " + TRAJECTORYANGLE.
SET Density TO 1.225.
//lock g to constant:g * body:mass / body:radius^2.		// Gravity (m/s^2)	
lock g to GETGATALT(altitude).
SET Vt TO SQRT((2*SHIP:MASS*g)/(Cd*Density)).
SET FALLTIMEHMS TO (Vo/g)*2.
SET UoHMS TO Uo.
LOCK CALCHORV TO COS((ARCSIN(SHIP:VERTICALSPEED/SHIP:AIRSPEED)))*SHIP:AIRSPEED.
SET ymax TO (Vt^2 / (2 * g)) * ln ((Vo^2 + Vt^2)/Vt^2).
SET NEWG TO body:mu / (ymax + body:radius)^2.
SET Vt TO SQRT((2*SHIP:MASS*NEWG)/(Cd*GETDENSITY((ALTITUDE+ymax)/2))).
SET ymax TO (Vt^2 / (2 * NEWG)) * ln ((Vo^2 + Vt^2)/Vt^2).
SET AVGG TO (g+NEWG)/2.
SET FALLTIMENEW TO (Vo/AVGG)*2.
PRINT "YMAX: " + Ymax AT (0,9).
PRINT "EST FALLTIME: " + FALLTIMENEW AT (0,1).
SET X TO ((Vt*Vt)/AVGG)*(LN(((Vt*Vt)+AVGG*UoHMS*FALLTIMENEW)/(Vt*Vt))).
PRINT "Calculated X: " + X AT (0,3).
LOCK STEERING TO HEADING(90,90).
LOCK THROTTLE TO 1.0.

SET BURNSTARTINGSPOT to SHIP:GEOPOSITION.
SET CONTINUEBURN TO 1.
SET LASTESTIMATE TO 0.
SET FINEADJUST TO 0.
UNTIL CONTINUEBURN = 0 {
	
	// We need to limit speed for the computation to have any chance to keep up
	// TODO: Figure out a smarter way that calculates throttle based on how long til
	// impactX reaches target dist.
	SET THROTTLEPOS TO  (Vo/1.0) / SHIP:VERTICALSPEED.
	if (THROTTLEPOS > 1)
	{
		SET THROTTLEPOS TO 1.
	}
	IF (FINEADJUST = 1)
	{
		SET THROTTLEPOS TO 0.1.
	}
	PRINT "THROTTLEPOS: " + (THROTTLEPOS) AT (0,11).
	LOCK THROTTLE TO THROTTLEPOS.

	SET BURNDISTANCE TO GETGROUNDDIST(KSC).
	SET TRAJDIST TO GETEULERBALLX(ALTITUDE,0, CALCHORV, SHIP:VERTICALSPEED, Cd).
	
	// We need to compensate for slow computation.
	SET ESTDIFF TO TRAJDIST - LASTESTIMATE.
	SET LASTESTIMATE TO TRAJDIST.
	SET TOTALDIST TO BURNDISTANCE + TRAJDIST.
	IF ((TOTALDIST + (ESTDIFF*3)) > TARGETDIST * 0.9)
	{
		SET FINEADJUST TO 1.
	}
	IF ((TOTALDIST + (ESTDIFF*2)) > TARGETDIST)
	{
		LOCK THROTTLE TO 0.
		SET CONTINUEBURN TO 0.
		PRINT "FINAL IMPACT: " + (TRAJDIST) AT (0,11).
		PRINT "KSC DIST: " + (BURNDISTANCE) AT (0,12).
		PRINT "TOTAL: " + (TOTALDIST) AT (0,7).
		PRINT "ESTDIFF: " + (ESTDIFF) AT (0,8).
	}
	


	PRINTDATA().
	//LOCK THROTTLE TO 1.0.
	IF (APOAPSIS > 500)
	{
		LOCK STEERING TO HEADING(90,TRAJECTORYANGLE).
	}
	SET TRAJECTORYANGLE TO (ARCTAN(CALCHORV/SHIP:VERTICALSPEED)).
	PRINT "G: " + g AT (0,30).
	PRINT "EST DENSITY: " + GETDENSITY(ALTITUDE) AT (0,31).
	PRINT "CALC Q: " + (GETDENSITY(ALTITUDE) * 0.5 * SHIP:AIRSPEED * SHIP:AIRSPEED) AT (0,32).
	PRINT "GIVEN Qkpa: " + (SHIP:Q*constant:AtmToKpa) AT (0,33).
	PRINT "GIVEN Q: " + (SHIP:Q * 101325) AT (0,17).
	SET CALCDENS TO ((SHIP:Q*101325)/(0.5*SHIP:AIRSPEED*SHIP:AIRSPEED)).
	PRINT "CALC DENS: " + CALCDENS AT (0,34).
	SET CALCDENS2 TO ((SHIP:Q)/(0.5*SHIP:AIRSPEED*SHIP:AIRSPEED)).
	PRINT "CALC DENS2: " + CALCDENS2 AT (0,15).
	SET CALCDENS3 TO (((GETDENSITY(ALTITUDE) * 0.5 * SHIP:AIRSPEED * SHIP:AIRSPEED))/(0.5*SHIP:AIRSPEED*SHIP:AIRSPEED)).
	PRINT "CALC DENS3: " + CALCDENS3 AT (0,16).
	PRINT "AIRSPEED: " + SHIP:AIRSPEED AT (0,37).
	
	
	
	RCS ON.
}
LOCK THROTTLE TO 0.
LOCK STEERING TO PROGRADE.
wait 1.
PRINT "ACTAUL Uo: " + CALCHORV AT (0,13).
PRINT "ACTUAL Vo: " + SHIP:VERTICALSPEED AT (0,14).
SET NEWDENSITY TO Density.
//(0.898+0.642)/2.
//SET NEWVt TO SQRT((2*SHIP:MASS*g)/(Cd*GETDENSITY((ALTITUDE+(ALTITUDE+ymax))/2))).
SET NEWVT TO 1.
SET FALLTIMENEW TO ((SHIP:VERTICALSPEED)/g)*2.
SET XNEW TO ((NEWVt*NEWVt)/g)*(LN(((NEWVt*NEWVt)+g*CALCHORV*FALLTIMENEW)/(NEWVt*NEWVt))).
SET XNEW TO GETBALLISTICX(ALTITUDE,CALCHORV, SHIP:VERTICALSPEED, Cd).
//PRINT "NEW ESTIMATE: " + XNEW AT (0,4).
PRINT "NEW FALLTIME: " + FALLTIMENEW AT (0,5).
PRINT "NEWER ESTIMATE: " + GETEULERBALLX(ALTITUDE,ALTITUDE, CALCHORV, SHIP:VERTICALSPEED, Cd) AT (0,4).
PRINT "NEWER IMPACT: " + GETEULERBALLX(ALTITUDE,0, CALCHORV, SHIP:VERTICALSPEED, Cd) AT (0,6).

SET YMAXNEW TO (NEWVt^2 / (2 * g)) * ln ((SHIP:VERTICALSPEED^2 + NEWVt^2)/NEWVt^2).
PRINT "NEW YMAX: " + (YMAXNEW + ALTITUDE) AT (0,10).


UNTIL (FALSE)
{
	PRINTDATA().
	// Gliding test
	IF (SHIP:VERTICALSPEED < 0)
	{
		SET BURNDISTANCE TO GETGROUNDDIST(KSC).
		SET TRAJDIST TO GETEULERBALLX(ALTITUDE,0, CALCHORV, SHIP:VERTICALSPEED, Cd).
		
		// We need to compensate for slow computation.
		SET ESTDIFF TO TRAJDIST - LASTESTIMATE.
		SET LASTESTIMATE TO TRAJDIST.
		SET TOTALDIST TO BURNDISTANCE + TRAJDIST.
		IF ((TOTALDIST + (ESTDIFF*3)) > TARGETDIST * 0.9)
		{
			SET FINEADJUST TO 1.
		}
		SET IMPACTERROR TO (TOTALDIST + (ESTDIFF*2)) - TARGETDIST.
		PRINT "IMPACTERROR: " + IMPACTERROR AT (20,2).

		IF (IMPACTERROR < -100)
		{
			// Try to glide further
			LOCK STEERING TO HEADING(90,5).
		} ELSE IF (IMPACTERROR > 100)
		{
			// Try to glide down
			LOCK STEERING TO HEADING(90,-90).
		} ELSE {
			LOCK STEERING TO PROGRADE.
		}
		
	}
}.

SET STARTINGALT TO ALTITUDE.
SET STARTINGSPOT to SHIP:GEOPOSITION.
SET STARTTIME TO TIME:SECONDS.
SET STARTHORV TO CALCHORV.
SET STARTVERV TO SHIP:VERTICALSPEED.
SET MAXALT TO 0.
UNTIL (ALTITUDE < STARTINGALT)
{
	PRINTDATA().
	PRINT "G: " + g AT (0,30).
	RCS OFF.
	IF (MAXALT < ALTITUDE)
	{
		SET MAXALT TO ALTITUDE.
	}
}
BRAKES ON.
RCS ON.
SET REALDISTANCE TO STARTINGSPOT:DISTANCE.
PRINT "REAL DISTANCE: " + REALDISTANCE AT (0,6).
SET REALTIME TO (TIME:SECONDS - STARTTIME).
PRINT "REAL TIME: " + REALTIME AT (0,7).
PRINT "REAL MAXY: " + MAXALT AT (0,8).
if (FALSE) {
SET TARGETALT TO 100.
//LOCK STEERING TO UP.
//LOCK THROTTLE TO 1.0.
wait 5.
// LOCK STEERING TO RETROGRADE.
UNTIL (XNEW > REALDISTANCE)
{
	PRINT "CALCULCATING NEW Cd..." + Cd AT (0,15).
	PRINT "NEWX: " + XNEW AT (0,16).
	
	SET Cd TO Cd - 0.0001.
	IF (Cd < 0.0002) { BREAK. }.
	SET PEAKG TO body:mu / (MAXALT + body:radius)^2.

	SET AVGG TO (PEAKG+NEWG)/2.
	SET NEWVt TO SQRT((2*SHIP:MASS*g)/(Cd*GETDENSITY((ALTITUDE+(ALTITUDE+MAXALT))/2))).
	SET FALLTIMENEW TO ((STARTVERV)/AVGG)*2.
	SET XNEW TO ((NEWVt*NEWVt)/AVGG)*(LN(((NEWVt*NEWVt)+AVGG*STARTHORV*FALLTIMENEW)/(NEWVt*NEWVt))).
	IF (SHIP:VERTICALSPEED < 1.0)
	{
		LOCK TWR TO ((SHIP:MAXTHRUST*1000)/((SHIP:MASS*1000)*g)).
		//SET THROTTLE TO (1.0/TWR) - SHIP:VERTICALSPEED.
	}
	IF (SHIP:GROUNDSPEED < 5.0)
	{
		//LOCK STEERING TO HEADING(90,90).
	}
}

UNTIL (FALSE)
{
	PRINTDATA().
	IF (SHIP:VERTICALSPEED < -1.0)
	{
		LOCK TWR TO ((SHIP:MAXTHRUST*1000)/((SHIP:MASS*1000)*g)).
		//LOCK THROTTLE TO (1.0/TWR) - (SHIP:VERTICALSPEED+(ALT:RADAR/10)).
	}
	IF (SHIP:GROUNDSPEED < 5.0)
	{
		//LOCK STEERING TO HEADING(90,90).
	}
}
}.